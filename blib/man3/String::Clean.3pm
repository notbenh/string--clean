.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "String::Clean 3"
.TH String::Clean 3 "2007-12-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
String::Clean \- use data objects to clean strings
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The goal of this module is to assist in the drudgery of string cleaning by 
allowing data objects to define what and how to clean. 
.Sh "\s-1EXAMPLES\s0"
.IX Subsection "EXAMPLES"
.Vb 1
\&   use String::Clean;
.Ve
.PP
.Vb 1
\&   my $clean = String::Clean\->new();
.Ve
.PP
.Vb 2
\&   $clean\->replace( { this => 'that', is => 'was' } , 'this is a test' ); 
\&      # returns 'that was a test'
.Ve
.PP
.Vb 1
\&   # see the tests for more examples
.Ve
.SH "THE OPTIONS HASH"
.IX Header "THE OPTIONS HASH"
Each function can take an optonal hash that will change it's behaviour. This 
hash can be passed to new and will change the defaults, or you can pass to each
call as needed. 
.PP
.Vb 7
\&   opt: 
\&         Any regex options that you want to pass, ie {opt => 'i'} will allow 
\&         for case insensitive manipulation.
\&   replace : 
\&         If the value is set to 'word' then the replace function will look for 
\&         words instead of just a collection of charicters. 
\&         example:
.Ve
.PP
.Vb 3
\&            replace( { is => 'was' },
\&                     'this is a test',
\&                   );
.Ve
.PP
.Vb 1
\&            returns 'thwas was a test', where
.Ve
.PP
.Vb 4
\&            replace( { is => 'was' },
\&                     'this is a test',
\&                     { replace => 'word' },
\&                   );
.Ve
.PP
.Vb 1
\&            will return 'this was a test'
.Ve
.PP
.Vb 3
\&   strip :
\&         Just like replace, if the value is set to 'word' then strip will look
\&         for words instead of just a collection of charicters.
.Ve
.PP
You can also override options at the function level again, but this happens as
merged hash, for example:
.PP
.Vb 3
\&   my $clean = String::Clean\->new({replace => 'word', opt => 'i'});
\&   $clean\->strip( [qw{a}], 'an Array', {replace =>'non\-word'} );
\&   #returns 'n rray' because opt => 'i' was pulled in from the options at new.
.Ve
.SH "CORE FUNCTIONS"
.IX Header "CORE FUNCTIONS"
.Sh "replace"
.IX Subsection "replace"
Takes a hash where the key is what to look for and the value is what to replace
the key with.
.PP
.Vb 1
\&   replace( $hash, $string, $opts );
.Ve
.Sh "replace_word"
.IX Subsection "replace_word"
A shortcut that does the same thing as passing {replace => 'word'} to replace.
.PP
.Vb 1
\&   replace_word( $hash, $string, $opts );
.Ve
.Sh "strip"
.IX Subsection "strip"
Takes an arrayref of items to completely remove from the string.
.PP
.Vb 1
\&   strip( $list, $sring, $opt);
.Ve
.Sh "strip_word"
.IX Subsection "strip_word"
A shortcut that does the same thing as passing {strip => 'word'} to strip.
.PP
.Vb 1
\&   strip_word( $list, $string, $opt);
.Ve
.SH "WRAPPING THINGS UP AND USING YAML"
.IX Header "WRAPPING THINGS UP AND USING YAML"
.Sh "clean_by_yaml"
.IX Subsection "clean_by_yaml"
Because we have to basic functions that take two seperate data types... why 
not wrap those up, enter \s-1YAML\s0. 
.PP
.Vb 1
\&   clean_by_yaml( $yaml, $string, $opt );
.Ve
.PP
But how do we do that? Heres an example:
.PP
\fI\s-1OLD\s0 \s-1CODE\s0\fR
.IX Subsection "OLD CODE"
.PP
.Vb 8
\&   $string = 'this is still just a example for the YAML stuff';
\&   $string =~ s/this/that/;
\&   $string =~ s/is/was/;
\&   $string =~ s/\eba\eb/an/;
\&   $string =~ s/still//;
\&   $string =~ s/for/to explain/;
\&   $string =~ s/\es\es/ /g;
\&   # 'that was just an example to explain the YAML stuff'
.Ve
.PP
\fI\s-1NEW\s0 \s-1CODE\s0\fR
.IX Subsection "NEW CODE"
.PP
.Vb 14
\&   $string = 'this is still just a example for the YAML stuff';
\&   $yaml = q{
\&   \-\-\-
\&   this : that
\&   is   : was
\&   a    : an
\&   \-\-\-
\&   \- still
\&   \-\-\-
\&   for : to explain
\&   '  ': ' '
\&   };
\&   $string = $clean\->clean_by_yaml( $yaml, $string, { replace => 'word' } );
\&   # 'that was just an example to explain the YAML stuff'
.Ve
.PP
\fI\s-1ISSUES\s0 \s-1TO\s0 \s-1WATCH\s0 \s-1FOR:\s0\fR
.IX Subsection "ISSUES TO WATCH FOR:"
.IP "* Order matters:" 4
.IX Item "Order matters:"
As you can see in the example we have 3 seperate \s-1YAML\s0 docs, this allows for
replaces to be doene in a specific sequence, if that is needed. Here in this
example is would not have mattered that much, here's a better example:
.Sp
.Vb 9
\&   #swap all instances of 'ctrl' and 'alt' 
\&   $yaml = q{
\&   \-\-\-
\&   ctrl : __was_ctrl__
\&   \-\-\-
\&   alt  : ctrl
\&   \-\-\-
\&   __was_ctrl__ : alt
\&   };
.Ve
.IP "* Options are global to the \s-1YAML\s0 doc :" 4
.IX Item "Options are global to the YAML doc :"
If you need to have seperate options applied to seperate sets then they
will have to happen as seprate calls.
.SH "AUTHOR"
.IX Header "AUTHOR"
ben hengst, \f(CW\*(C`<notbenh at CPAN.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-string\-clean at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=String\-Clean>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc String::Clean
.Ve
.PP
You can also look for information at:
.IP "* \s-1RT:\s0 \s-1CPAN\s0's request tracker" 4
.IX Item "RT: CPAN's request tracker"
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=String\-Clean>
.IP "* AnnoCPAN: Annotated \s-1CPAN\s0 documentation" 4
.IX Item "AnnoCPAN: Annotated CPAN documentation"
<http://annocpan.org/dist/String\-Clean>
.IP "* \s-1CPAN\s0 Ratings" 4
.IX Item "CPAN Ratings"
<http://cpanratings.perl.org/d/String\-Clean>
.IP "* Search \s-1CPAN\s0" 4
.IX Item "Search CPAN"
<http://search.cpan.org/dist/String\-Clean>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2007 ben hengst, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
